### 뷰 스타일 가이드를 조금의 개인 의견을 가미하여 정리한 내용입니다.
#### 원본 링크 : [뷰 스타일가이드](https://v3.ko.vuejs.org/style-guide/#%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%A9%E1%84%82%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3-%E1%84%89%E1%85%B3%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF-%E1%84%87%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B1-%E1%84%8C%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%BC-%E1%84%91%E1%85%B5%E1%86%AF%E1%84%89%E1%85%AE)
<br>

## 뷰 v3.0 기준의 스타일 가이드

|타입|명칭|상세설명|
|:---:|:---:|:---|
|A|필수|에러를 방지하는 데 도움이 되므로 무조건 학습하고 준수해야 합니다.<br>매우 드물게 예외가 있을 뿐 반드시 지켜줘야 하는 규칙입니다.|
|B|적극 권장|가독성을 높이고 개발자 경험을 향상시키므로 지켜주는 것이 좋으며 위반 시 그럴 만한 합당한 이유가 있어야 합니다.|
|C|권장|여러 좋은 선택 사항이 존재할 경우, 일관성을 보장하도록 제안이 되는 규칙입니다.<br>커뮤니티 표준에 가깝다고 볼 수 있습니다.|
|D|주의 필요|예외 사항을 수용하거나 레거시 코드(예전 버전의)를 마이그레이션 할 때 도움이 될 수 있는 규칙입니다.|

<br><br><br>

|제목|타입|상세설명|
|:---|:---:|:---|
|컴포넌트 이름에 합성어 사용|A|컴포넌트 이름은 루트 컴포넌트인 App과 Vue에서 제공하는 내장 컴포넌트(```<transition>, <component>``` 등)를 제외하고 항상 합성어를 사용해야 합니다.<br>모든 HTML 엘리먼트의 이름은 한 단어이기 때문에 합성어를 사용하는 것은 기존 그리고 향후 HTML 엘리먼트와의 충돌을 방지합니다.|
|Prop 정의 |A|Prop은 가능한 한 상세하게 정의해야 합니다. 최소한 type은 명시하도록 합니다.
|v-for에 key 지정|A|내부 컴포넌트 상태를 하위 트리로 유지하려면 v-for에 항상 key가 필요합니다.<br>이는 단순히 구분하기 위해서가 아닌 vue DOM 작동원리([in place patch 전략](https://goodteacher.tistory.com/525)) 상 하위 트리 구조를 유지하기 어렵기 때문에 반드시 추가하여야 합니다.|
|v-if와 v-for 동시 사용 피하기|A|v-for를 쓴 엘리먼트에 절대 v-if를 사용하지 마세요.<br>2.x 버전에선 v-for가 우선순위를, 3.x 버전에선 v-if가 우선순위를 가지며 이는 개발자로 하여금 큰 혼돈을 줍니다.|
|컴포넌트 스타일 범위 지정 |A|최상위 App 컴포넌트 및 레이아웃 컴포넌트의 스타일은 전역일 수 있지만, 그 외 모든 컴포넌트에는 항상 범위가 지정된 스타일을 적용해야 합니다.<br>Scoped를 사용하여 각 컴포넌트가 고유한 style을 적용 받는 것이 제공되지만 BEM 방법론과 같은 클래스 기반 전략 등을 사용하는 것이 더 좋습니다.|
|비공개 속성 이름|A|모듈 범위를 지정하여 외부에서 비공개 함수에 접근할 수 없도록 합니다. 범위 지정이 불가능한 경우, ```$_``` 접두사를 사용하며 이름이 지정된 범위를 포함해야 합니다.(ex:```$_yourPluginName_```)<br>이보다 methods에서 스코프 내에 선언된 function을 호출하여 사용하는 것이 더 나은 방법입니다.<br>이러한 처리로 다른 개발자와의 코드와 충돌하지 않도록 해야합니다.|
|컴포넌트 파일|B|빌드 시스템을 사용하여 파일을 연결할 때, 각 컴포넌트는 자체 파일에 속해야 합니다.(.vue 파일)<br>컴포넌트를 편집하거나 컴포넌트가 어떻게 사용되는지 검토할 때, 싱글 파일 컴포넌트(.vue)를 이용하면 컴포넌트를 보다 빠르게 파악할 수 있습니다.|
|싱글 파일 컴포넌트 파일 명명 규칙|B|싱글 파일 컴포넌트의 파일명은 항상 파스칼 케이스(PascalCase) 또는 케밥 케이스(kebab-case)여야 합니다.|
|베이스 컴포넌트 이름|B|애플리케이션 고유의 스타일과 규칙을 적용하는 베이스 컴포넌트(presentational, dumb, pure로도 잘 알려진 컴포넌트)의 이름은 모두 Base, App, 또는 V처럼 특정 접두사로 시작해야 합니다.|
|싱글 인스턴스 컴포넌트 이름|B|하나의 활성 인스턴스만을 갖는 컴포넌트는 오직 하나의 인스턴스만 있을 수 있음을 표시하도록 The 접두사로 시작해야 합니다.<br>이 말은 컴포넌트가 단일 페이지에서만 사용된다는 게 아니라, 페이지당 한 번만 사용되어야 한다는 의미입니다.(ex: 네비게이션 메뉴와 같은)|
|밀접하게 연관된 컴포넌트 이름|B|부모 컴포넌트와 밀접하게 연관된 자식 컴포넌트는 접두사로 부모 컴포넌트의 이름을 사용해야 합니다.<br/>코드 에디터는 주로 알파벳순으로 파일을 정렬하므로 연관된 컴포넌트 파일의 순서가 나란히 유지됩니다.|
|컴포넌트 이름의 단어 순서|B|컴포넌트 이름은 최상위 수준의 단어(대부분이 자주 또 일반적으로 사용하는 단어)로 시작하고 설명을 나타내는 단어로 끝나야 합니다.<br>이는 코드 에디터의 정렬 및 기능별 분류에 도움이 됩니다.|
|Self-closing 컴포넌트|B|싱글 파일 컴포넌트, 문자열 템플릿 및 JSX에서 내용이 없는 컴포넌트는 self-closing 처리해야 합니다. 하지만, DOM 템플릿에서는 그렇게 하면 안 됩니다.<br>*DOM 템플릿 : html 파일에서 사용하는 vue 템플릿 코드.|
|템플릿 내부 컴포넌트 명명 규칙|B|대부분의 프로젝트가 그렇듯, 싱글 파일 컴포넌트와 문자열 템플릿 안의 컴포넌트 이름은 항상 파스칼 케이스(PascalCase)여야 하며,<br>DOM 템플릿 안의 컴포넌트 이름은 케밥 케이스(kebab-case)여야 합니다.<br>이미 케밥 케이스(kebab-case)에 많은 투자를 했다면, 프로젝트 전반에 통일하여도 좋습니다.|
|JS/JSX 내부 컴포넌트 명명 규칙|B|JS/JSX 안의 컴포넌트 이름은 항상 파스칼 케이스(PascalCase)여야 하지만,<br>단순히 app.component로 등록한 전역 컴포넌트만을 사용하는 간단한 애플리케이션이라면 내부 문자열이 케밥 케이스(kebab-case)일 수 있습니다.|
|컴포넌트 전체(Full-word) 단어를 사용|B|컴포넌트명은 약어보다 전체 단어를 선호해야합니다.<br>에디터의 자동완성기능(autocompletion)은 긴 이름을 작성하는데 드는 비용을 매우 낮게 만들고, 컴포넌트 이름이 제공하는 명확성은 매우 중요합니다.<br>특히 일반적이지 않은 약어는 항상 피해야합니다.|
|prop명 대소문자|B|prop명은 선언 중에는 항상 camelCase를 사용해야하지만, 템플릿 및 JSX에서는 kebab-case를 사용해야 합니다.<br>단순히 각 언어의 규칙을 따르자면, JavaScript 내에서 camelCase가 자연스럽고 HTML내에서는 kebab-case만 존재할 수 있습니다.|
|다중-속성 요소(Multi-attribute elements)|B|JavaScript에서 여러 속성을 가진 객체를 여러 줄에 걸쳐 분할하는 것은 훨씬 읽기 쉽기 때문에, 많이 사용되는 좋은 규칙입니다.<br>템플릿과 JSX는 동일한 고려사항을 갖습니다.|
|템플릿의 간단한 표현|B|템플릿의 복잡한 식은 선언적이지 않습니다. 그 값을 계산하는 방법이 아니라 무엇을 표시해야 하는지 설명하려고 노력해야합니다.<br>computed 및 methods를 사용하면 코드를 재사용할 수 있습니다. *함수형 프로그래밍 권장|
|간단한 computed 속성|B|복잡한 computed 속성은 가능한 한 여러 개의 간단한 속성으로 분할해야합니다.<br>테스트 하기 쉬움(Easier to test) : 다른 변수와의 종속성이 거의 없는 매우 간단한 표현식만 있으면 작동여부를 테스트하는 데 수월합니다.<br>읽기 쉬움(Easier to read) : 명칭을 직관적이게 하여 본인 및 다른 개발자가 명칭만으로도 해석이 가능하고 파악할 수 있는 것이 좋습니다. *함수형 프로그래밍의 의의<br>변화하는 요구사항에 더 적응(adaptable)하기 좋음 : computed를 최종적인 목적을 지닌 하나의 값보다 기능을 잘게 쪼개어 조합하는 것이 변화에 유연하고 재사용에 좋습니다.|
|인용된 속성 값(Quoted attribute values)|B|비어있지 않은 HTML 속성 값은 항상 따옴표 안에 있어야 합니다 (JS에서 사용되지 않는 작은 따옴표 또는 큰 따옴표).<br>공백이 없는 속성 값은 HTML에서 따옴표를 사용할 필요가 없지만, 이 방법은 종종 공백을 피하여 속성 값을 읽기 어렵게 만듭니다.|
|디렉티브 약어(Directive shorthands) |B|디렉티브 약어는 모두 통일해서 사용하거나 전부 사용하지 않아야 합니다. (: 는 v-bind:, @ 는 v-on:, # 는 v-slot)|
|컴포넌트와 인스턴스 옵션 순서|C|컴포넌트와 인스턴스 옵션의 순서는 일관성 있게 정렬되어야 합니다.(name, components, props, data 등의 vue 인스턴스 속성의 선언 순서)|
|요소 속성 순서|C|요소(컴포넌트 포함)의 속성은 일관되게 정렬되어야 합니다.(is, v-for, v-if, id, v-on 등의 바인딩 속성)|
|컴포넌트/인스턴스 옵션의 빈 줄(empty lines)|C|컴포넌트가 비좁거나 읽기 어려운 느낌이 들기 시작하면 여러 줄 속성 사이에 공백을 추가하면 다시 쉽게 훑어 볼 수 있습니다.|
|싱글 파일 컴포넌트 최상위 엘리먼트 순서|C|싱글 파일 컴포넌트는 적어도 <script>나 <template> 중 하나가 항상 필요하기 때문에 <style>를 마지막에 두어 <script>, <template>, <style> 태그를 일관성있게 정렬해야 합니다.|
|scoped가 지정된 요소 선택기 |D|요소 선택자는 scoped로 피해야합니다. 많은 수의 요소 선택자가 느리기 때문에, scoped 스타일의 요소 선택자보다 클래스 선택자를 선호합니다.<br>* html 태그 요소에 style 속성을 넣을 경우 scoped 옵션 사용 시 상당히 느리므로 class에 style 속성을 넣을 것을 권장.|
|암시적 부모-자식 통신|D|부모-자식 컴포넌트 통신 시 this.$parent나 props 변경 대신, props down, event up을 사용하여야 합니다.<br>이상적인 Vue 애플리케이션은 props down, events up입니다. 이 규칙을 고수하면 컴포넌트를 훨씬 더 쉽게 이해할 수 있습니다.<br>단기적인 편의성을 위해 this.$parent를 사용할 수 있지만 이는 컴포넌트의 쉬운 이해를 해치게 됩니다.|
|비 플럭스(Non-flux) 상태 관리|D|flux는 부모컴포넌트에서 자식으로 속성을 통한 단방향 데이터 흐름을 의미.<br>this.$root에서 상태를 관리하거나 전역 이벤트 버스를 사용하는 것은 매우 간단한 경우에는 편리할 수 있지만, 대부분의 애플리케이션에는 적합하지 않습니다.|
  


### 스타일 가이드에 따른 Vue 개발 규약
<br>
위의 스타일 가이드를 기반으로 정리한 Vue 개발 규약입니다.<br>
이는 Vue 3.0 스타일 가이드 공식 문서와 기타 Vue 공식 문서를 기반으로 작성되었음을 알려드립니다.<br>
<br><br>



#### 1. SFC(싱글 파일 컴포넌트) 파일 명명 규칙
SFC 파일 명명 규칙은  여섯 가지입니다.<br>
<br>
첫 번째, 컴포넌트 이름은 Root 컴포넌트인 App과 Vue에서 제공하는 내장 컴포넌트(<transition>, <component> 등)를 제외하곤 항상 두 단어 이상의 합성어를 사용합니다.<br>
모든 HTML 엘리먼트의 이름은 한 단어이기 때문에 합성어를 사용하는 것은 기존 그리고 향후 HTML 엘리먼트와의 충돌을 방지하고 Vue 컴포넌트를 명확히 구분할 수 있습니다.<br>




두 번째, 컴포넌트 이름은 항상  항상 파스칼 케이스(PascalCase)여야 합니다.

위의 첫 번째 합성어에 의거하여 두 단어를 사용할 수 있는 네이밍 컨벤션 중에서 고려할 수 있는건 파스칼 케이스와 케밥 케이스입니다.

주 사용하는 개발 환경 OS인 윈도우와 맥OS는 파일시스템의 대소문자 구분에 문제가 없으므로 가장 최적화가 좋은 파스칼 케이스로 작성합니다.




세 번째, 베이스 컴포넌트 이름은 Base, App, V 등 세 가지 접두사로 시작한 합성어여야 합니다.

어플리케이션 고유의 스타일과 규칙을 적용하는 베이스 컴포넌트를 작성할 경우 용도의 구분을 위해 정해진 세 가지 접두사만을 사용하여야 합니다.




네 번째, 싱글 인스턴스 컴포넌트 이름은 반드시 The 접두사로 시작한 합성어여야 합니다.

한 페이지당 하나의 활성 인스턴스만을 갖는 컴포넌트는 오직 하나의 인스턴스만을 있을 수 있음을 표시하도록 The 접두사로 시작해야 합니다.




다섯 번째, 밀접하게 연관된 부모, 자식간의 컴포넌트 이름은 접두사로 부모 컴포넌트 이름을 사용해야 합니다.

이는 알파벳 순으로 정렬하는 코드 에디터에서 순서가 나란히 유지되어 부모, 자식관의 연관 관계와 가독성을 높여줍니다. 




여섯 번째, 컴포넌트 이름의 단어 순서는 상위 수준의 단어(대부분이 자주 또 일반적으로 사용하는 단어)로 시작하고 설명을 나타내는 단어로 끝나야 합니다.

예를 들면 SearchButtonClear.vue 와 같은 형식의 사용을 권장하며 이는 코드 에디터의 정렬 및 기능별 분류에 도움이 됩니다.







2. 파일 내부 컴포넌트 명명 규칙

파일 내부에서 컴포넌트를 사용 시 세 가지 핵심 명명 규칙이 있습니다. 




 

첫 번째, 파일 내부에서 컴포넌트를 기술 할 때 파스칼 케이스로 Import 하고 뷰 인스턴스 등록 시 케밥 케이스(kebab-case)로 사용합니다.

파스칼 케이스가 케밥 케이스보다 장점이 많지만 템플릿 내부에서 사용 시 DOM 템플릿일 경우 HTML은 대소문자를 구분할 수 없으므로 범용성이 큰 케밥 케이스를 사용하도록 합니다.   

(* JS에서 파스칼 케이스는 인스턴스를 가질 수 있는 객체를 의미하는 문법이므로 뷰의 컴포넌트 또한 그 의미가 같으므로 파스칼 케이스의 자기서술적인 장점이 더 크긴 합니다.)







두 번째, 템플릿 내부에서 컴포넌트를 사용 시 내용이 없는 컴포넌트는 self-closing 처리를 해야 합니다.

Slot이 들어가는 컴포넌트나 DOM 템플릿에서는 self-closing 하여선 안됩니다.







세 번째, 컴포넌트명은 약어보다 전체 단어를 사용하여 작성합니다.

코드 에디터는 자동 완성 기능을 제공하므로 긴 이름에 대한 부담이 적고 이에 비해 정확한 단어가 제공하는 이름의 명확성이 주는 자기 서술성의 효과가 더 크므로 전체 단어를 사용합니다.

따라서 굳이 약어를 쓸 경우, 일반적으로 자주 쓰이며 중복이 되지 않는 약어를 사용합니다.  










3. 컴포넌트와 인스턴스의 일관성 있는 옵션 순서

컴포넌트와 인스턴스 옵션의 순서는 용도에 따라 일관성 있게 정렬되어야 합니다.

다음은 Vue 공식 스타일 가이드에서 권장되는 기본 순서입니다. 유형 별로 나누어 놓았으므로 플러그인에서 추가한 속성들 역시 이에 맞추어 정렬하면 됩니다.




1. 전역 인지(Global Awareness) (컴포넌트 바깥의 지식을 필요로 하는 옵션)

name






2. 템플릿 변경자(Template Modifiers) (템플릿 컴파일 방식 변경)

delimiters






3. 템플릿 종속성(Template Dependencies) (템플릿에서 사용된 에셋)

components
directives






4. 구성, 합성(Composition) (속성들을 옵션에 병합)

extends
mixins
provide/inject






5.  인터페이스(Interface) (컴포넌트에 대한 인터페이스)

inheritAttrs
props
emits






6. 컴포지션 API(Composition API) (Composition API 사용을 위한 진입점)

setup






7. 로컬 상태(Local State) (로컬 반응형 속성)

data
computed






8. 이벤트(Events) (반응형 이벤트에 의해 트리거된 콜백)

watch






9. 라이프사이클 이벤트들 (호출된 순서)


beforeCreate
created
beforeMount
mounted
beforeUpdate
updated
activated
deactivated
beforeUnmount
unmounted
errorCaptured
renderTracked
renderTriggered






10. 비-반응형 속성(Non-Reactive Properties) (반응성 시스템과 무관한 인스턴스 속성)

methods






11. 렌더링(Rendering) (컴포넌트 출력에 대한 선언적 설명)

template/render














4. 컴포넌트 요소 속성(디렉티브 등) 순서

디렉티브와 같이 컴포넌트에 바인딩하는 요소에 대한 순서 또한 유형 별로 일관성 있게 선언하면 개발 시 사용자지정 속성 및 디렉티브를 새롭게 추가할 때 도움이 됩니다.

다음은 Vue 공식 스타일 가이드에서 권장되는 기본 순서입니다.




1. 정의(Definition) (컴포넌트 옵션 제공)

is


2. 리스트 렌더링(List Rendering) (동일한 요소의 여러 변형 생성)

v-for





3. 조건(Conditionals) (요소가 렌더링/표시될 지 여부)

v-if
v-else-if
v-else
v-show
v-cloak



4. 렌더 수식어(Render Modifiers) (요소 렌더링 방식 변경)

v-pre
v-once



5. 전역 인지(Global Awareness) (컴포넌트 바깥의 지식을 필요로 하는 옵션)

id



6. 고유 속성(Unique Attributes) (고유 값이 필요한 속성)

ref
key



7. 양방향 바인딩(Two-Way Binding) (바인딩 및 이벤트 결합)

v-model



8. 기타 속성(Other Attributes) (모든 지정되지 않은 바인딩, 언바인딩 속성)




9. 이벤트(Events) (컴포넌트 이벤트 리스너)

v-on






10. 컨텐츠(Content) (요소의 컨텐츠를 재정의함)

v-html
v-text











5. Prop과 Emit 정의




Prop은 Vue 인스턴스에서 props에 기술하며 emit은 emits에 기술합니다.

이때 emit은 배열 방식을 사용하여도 괜찮지만 Prop은 배열 방식이 아닌 객체 방식으로 최대한 상세하게 선언해야 하며 최소한 type은 명시하여야 합니다.










6. Prop 명명 규칙







prop명은 선언 중에는 항상 카멜 케이스를 사용해야 하지만, 템플릿 및 JSX에서는 케밥 케이스를 사용해야 합니다.

이는 단순한 이유입니다. JS에서 선언 시 카멜 케이스가 자연스럽고 HTML에서는 케밥 케이스만이 존재 할 수 있기 때문입니다.










7.  v-for에 key 지정




v-for 사용 시 반드시 key를 바인딩 시켜야 합니다.

이는 단순히 반복된 엘리먼트를 구분하기 위해서가 아닌 Vue에서 가상 DOM의 작동 원리인 in place patch 전략에 따라 반복된 엘리먼트의 하위 트리 구조를 유지하기 어렵기 때문에 반드시 추가하여야 합니다.










8.  v-if와 v-for 동시 사용 피하기




v-for를 쓴 엘리먼트에 절대 v-if를 사용하여선 안됩니다.

2.x 버전에선 v-for가 우선순위를, 3.x 버전에선 v-if가 우선순위를 가지며 이는 개발자로 하여금 큰 혼돈을 줍니다.

따라서 원하는 우선순위 의도에 따라 v-if를 v-for 내부에 둘 지 혹은 외부에서 감싸 놓을 지를 명확히 구분해서 사용합시다. 










9.  템플릿의 간단한 표현 추구







템플릿에서 복잡한 표현식을 사용하는 것은 직관적이지 않아 해석에 악영향을 줍니다.

함수형 프로그래밍 패러다임에 따라 표현식에선 값을 계산하는 방법을 서술하는 것이 아닌 무엇을 표시하려는지 설명해야 합니다.

따라서 복잡한 표현식이 필요한 경우 computed에 선언을 합니다.

(* 참고로 computed는 vue 반응성 시스템에 따라 종속성 검사를 거친 후 실행 됩니다. 관련 링크)










10.  간단한 computed







coumputed 속성은 복잡해지지 않도록 여러 개의 간단한 computed 속성으로 분할하여야 합니다.

작게 분류된 computed 속성은 조합 시 보다 직관적이며 요구사항 변경에 따른 리팩토링에 대해서도 유연합니다.




그리고 추가로 핵심 장점 세 가지를 서술하자면 다음과 같습니다.




● 테스트 하기 쉬움(Easier to test)

다른 변수와의 종속성이 거의 없는 매우 간단한 표현식만 있으면 작동여부를 테스트하는 데 수월합니다.




● 읽기 쉬움(Easier to read)

명칭을 직관적이게 하여 본인 및 다른 개발자가 명칭만으로도 해석이 가능하고 파악할 수 있는 것이 좋습니다. 절차적이지 않고 선언적인 프로그래밍을 지향해야합니다.




● 변화하는 요구사항에 더 적응(adaptable)하기 좋음

computed를 최종적인 목적을 지닌 하나의 값보다 기능을 잘게 쪼개어 조합하는 것이 변화에 유연하고 재사용성이 좋습니다.










11. 디렉티브 약어(Directive shorthands) 일관성 유지




디렉티브 약어는 모두 쓰거나, 쓰지 말아야 합니다. (: 는 v-bind:, @ 는 v-on:, # 는 v-slot)

약어의 혼용은 개발자로 하여금 혼란을 가하게 되므로 혼용은 지양해야 합니다.










12. 부모-자식 컴포넌트 통신 시 this.$parent나 props 변경 대신, props down, event up 사용.







Vue 작동 원리에 따르면 이상적인 Vue 어플리케이션은 props down, events(emits) up입니다.

이 규칙을 유지하면 컴포넌트를 훨씬 쉽게 이해가 가능하며 디버깅이 쉬워집니다.




그러나 readonly인 prop을 변경하거나 this.$parent를 접근하여 사용한다면 훨씬 코드 작성이 단순화 될 수도 있습니다.

그렇지만 작동 원리에 위배된 이러한 단기적인 편리함은 문제점을 야기 시킬 수 있으므로 지양하여야 합니다.







13. 직접적으로 DOM 접근이 필요한 경우, Real DOM 접근이 아닌 ref를 사용.







Vue는 가상 DOM(Virtual DOM)을 사용하기 때문에 Real DOM을 접근하여 사용 시 가상 DOM의 이점이 잃게 되며 이에 따라 비동기 업데이트 큐(Async update queue)에도 문제가 생길 수 있습니다.

따라서 querySelector나 getElementBy... 이 아닌 ref를 사용하여 DOM에 접근하는 것을 권장합니다.







14.  DOM 상태에 따라 개발하지 말고 구성 요소(data, computed)의 상태에 따라 개발.







전통적인 프론트엔드 UI 개발 시 DOM 요소의 상태를 판별해서 개발하는 경우가 많지만 Vue에서는 구성 요소의 상태에 따라 개발하는 것이 좋습니다.

Vue에서는 비동기 업데이트 큐(Async update queue)에 따라 DOM의 상태가 업데이트 되는 시점이 일정치 않습니다.

따라서 직접적인 DOM 요소의 상태보다는 data나 computed 요소 상태에 따라 로직을 짜는 것이 권장되며

vue 트랜지션을 사용하는 경우 트랜지션 훅을 사용하는 것이 좋습니다.


그러나 불가피하게 DOM 요소에 직접적인 접근을 해야하는 경우 nextTick 콜백을 통해 해결할 수 있습니다.  
